#!/usr/bin/env Rscript
# 96 well spectrophotometer data analysis
# Copyright Jackson M. Tsuji (Neufeld Lab PhD student), 2018
# Created Nov 10th, 2016
# Description: Imports and processes data from the Neufeld lab 96 well plate reader

#####################################################
## User variables: #################################
RUN_COMMAND_LINE <- TRUE # If selected, all user input here is ignored, and terminal-based input is expected instead.

# Set other user variables here
if (RUN_COMMAND_LINE == FALSE) {
  setwd("/home/jmtsuji/Research_General/Bioinformatics/02_git/96-well-spec-analysis/") # your working directory where files are stored
  plate_data_filename <- c("testing/input/example_raw_plate_data.txt") # Raw data from the 96 well plate reader ('column/both' format, with default encoding)
  sample_metadata_filename <- "testing/input/example_sample_metadata.tsv" # Not needed if pre_parsed_data_file == FALSE
  output_filenames_prefix <- "testing/output_test/example_data_2" # Prefix for output files
  
  pre_parsed_data_file <- NULL # This is an optional setting to import pre-parsed raw data files (e.g., produced by this script previously) to re-analyze for sample concentrations (e.g., after making custom edits).
  # Set to NULL if you want to process raw files (plate_data_filename, sample_metadata_filename) instead.
  # Otherwise, set plate_data_filename and sample_metadata_filename to NULL, then set this variable to the name of the pre-parsed raw data file you want to re-analyze.
  # The script WILL NOT RUN if plate_data_filename, sample_metadata_filename, and pre_parsed_data_file are all set
  
  force_curve_through_zero <- TRUE # force the standard curve plots to go through (0,0)? (Recommended TRUE)
  
  library(rstudioapi) # NOT for users to change. comes in handy for loading functions into this script later
  repo_path <- dirname(getSourceEditorContext()$path)
} else {
  print(sys.frame(1)$ofile)
}

#####################################################
## Load required packages: ##########################
# Functions from original code
source("")

required_packages <- c("getopt", "glue", "plyr", "dplyr", "ggplot2", "grid", "reshape2", "xlsx")

# Check if the packages are already installed and exit if not
installed_check <- required_packages %in% installed.packages()[,1]
if (all(installed_check) == FALSE) {
  warning(paste("Missing required packages: ", c(required_packages[!installed_check]), ". ", sep = "", collapse = ))
  warning("See github page at https://github.com/jmtsuji/96-well-spec-analysis for a single line of code to install all required packages.")
}
# Load installed libraries
invisible(lapply(required_packages, function(x) {library(package = x, character.only = TRUE, warn.conflicts = FALSE, quietly = TRUE)}))
#####################################################

SCRIPT_VERSION <- "v0.3" # to match git tag

help_message <- function(params, message_length) {
  
  cat("96_well_spec_analysis.R: Analyzed 96 well spec data generated by the Neufeld lab's plate reader.\n")
  cat("Copyright Neufeld Lab, 2018\n")
  cat("Contact Jackson M. Tsuji (jackson.@uwaterloo.ca) for bug reports or feature requests.\n")
  cat(paste("Version: ", SCRIPT_VERSION, "\n\n", sep = ""))
  
  cat(getopt(spec = params, command = "96_well_spec_analysis.R", usage = TRUE))
  
  cat("\nSimple example: 96_well_spec_analysis.R -i spec_file.txt -m metadata_file.tsv -o analyzed_data\n\n")
  
  if (message_length == "full") {
    cat("Details:\n", "-i\t--spec_file\t\tFilepath for raw data file from the 96 well spec. [Required]\n",
        "-m\t--metadata_file\t\tFilepath for TSV-format file with metadata for each relevant spec well. See template in the Git repo, and see below for required columns. [Required]\n",
        "-o\t--run_name\t\tGeneral prefix for the script output (additional descriptors and file extensions will be added to the end of this) [Optional | Uses -i name otherwise]\n",
        "-p\t--pre_parsed_file\tAdvanced usage: optionally provide a file pre-parsed by this script with absorbance and metadata joined. Will only work if -i and -m are left empty. [Optional]\n",
        "-z\t--unforce_zero\t\tSet this flag to turn off the default of forcing the line of best fit through the origin. [Optional | Force through zero]\n\n")
    
    cat("Required columns in the metadata TSV file:\n",
        "* Plate_number: number sequentially from 1. Mostly important if your raw spec file contains more than one plate.\n",
        "* Well: the well ID in the 96 well plate (e.g., A1)\n",
        "* Sample_name: the name of the blank, unknown, or standard\n",
        "* Sample_type: MUST be one of 'Blank', 'Unknown', or 'Standard'\n",
        "* Blanking_group: e.g., 'Water' or 'Matrix' - can be whatever term you want. See README.md for more details on this.\n",
        "* Dilution_factor: how much the sample was diluted before input into the assay (e.g., 20 for a 20x dilution)\n",
        "* Standard_conc: the concentration of each standard. Can leave this blank or as 'NA' for non-standards.\n\n")
    
    cat("Potential additional columns in the metadata TSV file:\n",
        "(you can have as many columns in the file as you'd like -- they will be kept in the output data in case helpful for downstream analyses)\n",
        "* Standard_group: if you have more than one set of standards per plate, you MUST specify which samples correspond to which standard by including this column - the script knows to look for it.\n",
        "* Replicate: can be helpful to have the same 'Sample_name' for multiple (e.g., biological) replicates but very the 'Replicate' ID (e.g., A, B, C...)\n",
        "* Treatment: can be a helpful way to distinguish between different assayed parameters (e.g., NO2 versus NO2+NO3)\n",
        "* Date: e.g., if samples represent a time series\n\n")
  } else if (message_length == "short") {
    cat("Try '-h' flag to see the full help message.\n\n")
  } else {
    stop("Internal script ERROR: message_length must be either 'full' or 'short'. Exiting...")
  }
  
  quit(status = 1)
  
}

parse_command_line_input <- function() {
  ### Grab arguments
  # Arguments required:
  # -i input plate_data_filename
  # -m input sample_metadata_filename
  # -p pre_parsed_data_file
  # -z force_curve_through_zero
  # -o output_filenames_prefix (for output files)
  params <- matrix(c('spec_file', 'i', 2, "character",
                     'metadata_file', 'm', 2, "character",
                     'run_name', 'o', 2, "character",
                     'pre_parsed_file', 'p', 2, "character",
                     'unforce_zero', 'z', 2, "logical",
                     'help', 'h', 2, "logical"), byrow=TRUE, ncol=4)
  
  opt <- getopt(params)
  
  # If no inputs files were provided, go to help
  if ( is.null(opt$help) && is.null(opt$spec_file) && is.null(opt$metadata_file) && is.null(opt$pre_parsed_file) ) {
    help_message(params, "short")
  }
  
  # If help was called, print help message and exit
  if ( !is.null(opt$help) ) {
    help_message(params, "full")
  }
  
  # Determine if a plate file and metadata file were provided versus a pre-parsed file
  if ((is.null(opt$spec_file) == FALSE | is.null(opt$metadata_file) == FALSE) && is.null(opt$pre_parsed_file) == FALSE ) {
    # Quit if -i or -m AND -p were simultaneously set
    stop("ERROR: Cannot have the '-p' flag set at the same time as '-i' or '-m'. Exiting...")
  } else if (is.null(opt$pre_parsed_file) == FALSE) {
    input_mode <- "pre-parsed"
  } else if (is.null(opt$spec_file) == FALSE && is.null(opt$metadata_file) == FALSE) {
    input_mode <- "raw"
  } else if (is.null(opt$spec_file) == FALSE | is.null(opt$metadata_file) == FALSE) {
    # If both -i and -m were not set together (checked in previous if statement), then exit if at least one of them was selected (means that the other one was not)
    stop("ERROR: Need to have both '-i' and '-m' set to run in raw input mode. See -h for details. Exiting...")
  } else {
    stop("Something unexpected went wrong related to the '-p', '-i', and '-m' flags being set improperly. Exiting...")
  }
  
  # Exit if required input tables are not provided (different for different input modes)
  if (input_mode == "raw") {
    if ( is.null(opt$spec_file) ) {
      stop("Input plate data filepaths required. Try -h for help message.")
    }
    if ( is.null(opt$metadata_file) ) {
      stop("Input sample metdata filepath required. Try -h for help message.")
    }
  } else if (input_mode == "pre-parsed") {
    if ( is.null(opt$pre_parsed_file) ) {
      stop("Input pre-parsed absprbance/metadata table filepath required. Try -h for help message.")
    }
  } else {
    stop("Something unexpected went wrong related to the '-p', '-i', and '-m' flags being set improperly. Exiting...")
  }
  
  # Provide defaults for optional inputs if not provided
  
  if ( is.null(opt$unforce_zero) ) {
    opt$unforce_zero <- TRUE
  } else {
    opt$unforce_zero <- FALSE
  }
  if ( is.null(opt$run_name) ) {
    opt$run_name <- NA # Signal to determine properly later
  }
  
  # Make variables from provided input and save as global variables (<<-)
  # TODO - make CAPS
  input_mode <<- input_mode
  plate_data_filename <<- opt$spec_file
  sample_metadata_filename <<- opt$metadata_file
  pre_parsed_data_file <<- opt$pre_parsed_file
  force_curve_through_zero <<- opt$unforce_zero
  output_filenames_prefix <<- opt$run_name
  
}


calculate_individual_file_pairs <- function(plate_data_filename, sample_metadata_filename) {
  plate_table <- parse_raw_data(plate_data_filename, sample_metadata_filename)
  all_calculated_data <- calculate_all_data(plate_table)
  
  return(all_calculated_data)
}

main() {

  # Grab functions from helper script in the same folder
  # TODO - how to make this more elegant?
  source("./96_well_spec_analysis.R")
  
  # Load input files table
  input_file_pairs <- read.table(input_files_table_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
  
  # Make sure everything looks okay (e.g., files exist, and helper script exists?)
  test_input_file_pairs()
  
  # Analyze data individually for all files
  # Results in 8-member list for each file
  analyzed_data <- mclapply(1:nrow(input_file_pairs), 
           function(x) {calculate_individual_file_pairs(input_file_pairs[x,1], input_file_pairs[x,2])}, mc.cores = THREADS)
  names(analyzed_data) <- 1:nrow(input_file_pairs)
  # TODO - or have the user assign a name for each?
  
  output_summary_list <- mclapply(names(analyzed_data[[1]]), function(x) {subset_list(analyzed_data, item = x)}, mc.cores = THREADS)
  names(output_summary_list) <- names(analyzed_data[[1]])
  
  # Bind each list of tables together into a single table
  bound_summary_list <- mclapply(1:length(output_summary_list), 
                               function(x) { collapse_list(input_list = output_summary_list[[x]])}, mc.cores = THREADS)
  names(bound_summary_list) <- names(output_summary_list)
  
  
}

# Run the script only when called from command line, provided RUN_COMMAND_LINE == TRUE
# See https://stackoverflow.com/a/2968404 (accessed 180602)
if (interactive() == FALSE) {
  main()
} else if (RUN_COMMAND_LINE == FALSE) {
  main()
}
