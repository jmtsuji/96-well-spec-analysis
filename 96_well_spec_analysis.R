#!/usr/bin/env Rscript
# 96 well spectrophotometer data analysis
# Copyright Jackson M. Tsuji (Neufeld Lab PhD student), 2018
# Created Nov 10th, 2016
# Description: Imports and processes data from the Neufeld lab 96 well plate reader

#####################################################
## User variables: #################################
RUN_COMMAND_LINE <- TRUE # If selected, all user input here is ignored, and terminal-based input is expected instead.

# Set other user variables here
if (RUN_COMMAND_LINE == FALSE) {
  setwd("/home/jmtsuji/Research_General/Bioinformatics/02_git/96-well-spec-analysis/") # your working directory where files are stored
  plate_data_filename <- c("testing/input/example_raw_plate_data.txt") # Raw data from the 96 well plate reader ('column/both' format, with default encoding)
  sample_metadata_filename <- "testing/input/example_sample_metadata.tsv" # Not needed if pre_parsed_data_file == FALSE
  output_filenames_prefix <- "testing/output_test/example_data_2" # Prefix for output files
  
  pre_parsed_data_file <- NULL # This is an optional setting to import pre-parsed raw data files (e.g., produced by this script previously) to re-analyze for sample concentrations (e.g., after making custom edits).
  # Set to NULL if you want to process raw files (plate_data_filename, sample_metadata_filename) instead.
  # Otherwise, set plate_data_filename and sample_metadata_filename to NULL, then set this variable to the name of the pre-parsed raw data file you want to re-analyze.
  # The script WILL NOT RUN if plate_data_filename, sample_metadata_filename, and pre_parsed_data_file are all set
  
  force_curve_through_zero <- TRUE # force the standard curve plots to go through (0,0)? (Recommended TRUE)
}

#####################################################
## Load required packages: ##########################
required_packages <- c("getopt", "glue", "plyr", "dplyr", "ggplot2", "grid", "reshape2", "xlsx")

# Check if the packages are already installed and exit if not
installed_check <- required_packages %in% installed.packages()[,1]
if (all(installed_check) == FALSE) {
  warning(paste("Missing required packages: ", c(required_packages[!installed_check]), ". ", sep = "", collapse = ))
  warning("See github page at https://github.com/jmtsuji/96-well-spec-analysis for a single line of code to install all required packages.")
}
# Load installed libraries
invisible(lapply(required_packages, function(x) {library(package = x, character.only = TRUE, warn.conflicts = FALSE, quietly = TRUE)}))
#####################################################

SCRIPT_VERSION <- "v0.3" # to match git tag

help_message <- function(params, message_length) {
  
  cat("96_well_spec_analysis.R: Analyzed 96 well spec data generated by the Neufeld lab's plate reader.\n")
  cat("Copyright Neufeld Lab, 2018\n")
  cat("Contact Jackson M. Tsuji (jackson.@uwaterloo.ca) for bug reports or feature requests.\n")
  cat(paste("Version: ", SCRIPT_VERSION, "\n\n", sep = ""))
  
  cat(getopt(spec = params, command = "96_well_spec_analysis.R", usage = TRUE))
  
  cat("\nSimple example: 96_well_spec_analysis.R -i spec_file.txt -m metadata_file.tsv -o analyzed_data\n\n")
  
  if (message_length == "full") {
    cat("Details:\n", "-i\t--spec_file\t\tFilepath for raw data file from the 96 well spec. [Required]\n",
        "-m\t--metadata_file\t\tFilepath for TSV-format file with metadata for each relevant spec well. See template in the Git repo, and see below for required columns. [Required]\n",
        "-o\t--run_name\t\tGeneral prefix for the script output (additional descriptors and file extensions will be added to the end of this) [Optional | Uses -i name otherwise]\n",
        "-p\t--pre_parsed_file\tAdvanced usage: optionally provide a file pre-parsed by this script with absorbance and metadata joined. Will only work if -i and -m are left empty. [Optional]\n",
        "-z\t--unforce_zero\t\tSet this flag to turn off the default of forcing the line of best fit through the origin. [Optional | Force through zero]\n\n")
    
    cat("Required columns in the metadata TSV file:\n",
        "* Plate_number: number sequentially from 1. Mostly important if your raw spec file contains more than one plate.\n",
        "* Well: the well ID in the 96 well plate (e.g., A1)\n",
        "* Sample_name: the name of the blank, unknown, or standard\n",
        "* Sample_type: MUST be one of 'Blank', 'Unknown', or 'Standard'\n",
        "* Blanking_group: e.g., 'Water' or 'Matrix' - can be whatever term you want. See README.md for more details on this.\n",
        "* Dilution_factor: how much the sample was diluted before input into the assay (e.g., 20 for a 20x dilution)\n",
        "* Standard_conc: the concentration of each standard. Can leave this blank or as 'NA' for non-standards.\n\n")
    
    cat("Potential additional columns in the metadata TSV file:\n",
        "(you can have as many columns in the file as you'd like -- they will be kept in the output data in case helpful for downstream analyses)\n",
        "* Standard_group: if you have more than one set of standards per plate, you MUST specify which samples correspond to which standard by including this column - the script knows to look for it.\n",
        "* Replicate: can be helpful to have the same 'Sample_name' for multiple (e.g., biological) replicates but very the 'Replicate' ID (e.g., A, B, C...)\n",
        "* Treatment: can be a helpful way to distinguish between different assayed parameters (e.g., NO2 versus NO2+NO3)\n",
        "* Date: e.g., if samples represent a time series\n\n")
  } else if (message_length == "short") {
    cat("Try '-h' flag to see the full help message.\n\n")
  } else {
    stop("Internal script ERROR: message_length must be either 'full' or 'short'. Exiting...")
  }
  
  quit(status = 1)
  
}

parse_command_line_input <- function() {
  ### Grab arguments
  # Arguments required:
  # -i input plate_data_filename
  # -m input sample_metadata_filename
  # -p pre_parsed_data_file
  # -z force_curve_through_zero
  # -o output_filenames_prefix (for output files)
  params <- matrix(c('spec_file', 'i', 2, "character",
                     'metadata_file', 'm', 2, "character",
                     'run_name', 'o', 2, "character",
                     'pre_parsed_file', 'p', 2, "character",
                     'unforce_zero', 'z', 2, "logical",
                     'help', 'h', 2, "logical"), byrow=TRUE, ncol=4)
  
  opt <- getopt(params)
  
  # If no inputs files were provided, go to help
  if ( is.null(opt$help) && is.null(opt$spec_file) && is.null(opt$metadata_file) && is.null(opt$pre_parsed_file) ) {
    help_message(params, "short")
  }
  
  # If help was called, print help message and exit
  if ( !is.null(opt$help) ) {
    help_message(params, "full")
  }
  
  # Determine if a plate file and metadata file were provided versus a pre-parsed file
  if ((is.null(opt$spec_file) == FALSE | is.null(opt$metadata_file) == FALSE) && is.null(opt$pre_parsed_file) == FALSE ) {
    # Quit if -i or -m AND -p were simultaneously set
    stop("ERROR: Cannot have the '-p' flag set at the same time as '-i' or '-m'. Exiting...")
  } else if (is.null(opt$pre_parsed_file) == FALSE) {
    input_mode <- "pre-parsed"
  } else if (is.null(opt$spec_file) == FALSE && is.null(opt$metadata_file) == FALSE) {
    input_mode <- "raw"
  } else if (is.null(opt$spec_file) == FALSE | is.null(opt$metadata_file) == FALSE) {
    # If both -i and -m were not set together (checked in previous if statement), then exit if at least one of them was selected (means that the other one was not)
    stop("ERROR: Need to have both '-i' and '-m' set to run in raw input mode. See -h for details. Exiting...")
  } else {
    stop("Something unexpected went wrong related to the '-p', '-i', and '-m' flags being set improperly. Exiting...")
  }

  # Exit if required input tables are not provided (different for different input modes)
  if (input_mode == "raw") {
    if ( is.null(opt$spec_file) ) {
      stop("Input plate data filepaths required. Try -h for help message.")
    }
    if ( is.null(opt$metadata_file) ) {
      stop("Input sample metdata filepath required. Try -h for help message.")
    }
  } else if (input_mode == "pre-parsed") {
    if ( is.null(opt$pre_parsed_file) ) {
      stop("Input pre-parsed absprbance/metadata table filepath required. Try -h for help message.")
    }
  } else {
    stop("Something unexpected went wrong related to the '-p', '-i', and '-m' flags being set improperly. Exiting...")
  }
  
  # Provide defaults for optional inputs if not provided
  
  if ( is.null(opt$unforce_zero) ) {
    opt$unforce_zero <- TRUE
  } else {
    opt$unforce_zero <- FALSE
  }
  if ( is.null(opt$run_name) ) {
    opt$run_name <- NA # Signal to determine properly later
  }
  
  # Make variables from provided input and save as global variables (<<-)
  # TODO - make CAPS
  input_mode <<- input_mode
  plate_data_filename <<- opt$spec_file
  sample_metadata_filename <<- opt$metadata_file
  pre_parsed_data_file <<- opt$pre_parsed_file
  force_curve_through_zero <<- opt$unforce_zero
  output_filenames_prefix <<- opt$run_name
  
}

# Description: parses one plate from an input file
parse_individual_plate <- function(unparsed_plate_data, plate_ending_line, plate_num) {
  # test data
  # unparsed_plate_data <- unparsed_data
  # plate_ending_line <- plate_endings[1]
  # plate_num <- 1
  
  # Get the lines where the absorbance and well data is kept for the plate
  plate_lines <- c((plate_ending_line - 2), (plate_ending_line -1))
  
  # Pull the lines from the unparsed file
  plate_unparsed <- unparsed_plate_data[plate_lines]
  
  # Eliminate the first two tabs
  plate_unparsed <- gsub("^\t\t", "", plate_unparsed)
  
  # Make a table out of the absorbance data
  plate_parsed <- strsplit(plate_unparsed, "\t")
  names(plate_parsed) <- c("Well", "Absorbance")
  plate_parsed$Absorbance <- as.numeric(plate_parsed$Absorbance)
  plate_parsed <- data.frame("Plate_number" = plate_num, 
                             "Well" = plate_parsed[[1]], 
                             "Absorbance" = plate_parsed[[2]], 
                             stringsAsFactors = FALSE)
  
  return(plate_parsed)
}

# Description: loads one input file (can contain multiple plates)
parse_input_file <- function(file_name) {
  # Internal dependency functions: 'parse_individual_plate'
  
  # Read the vectorized input - got code here from the readLines help file
  con <- file(file_name, encoding = "UTF-16LE") # Assumed encoding based on the output of the plate reader software
  # TODO - try to detect this (or throw an error if it doesn't work?)
  unparsed_data <- readLines(con)
  close(con)
  # unique(Encoding(A))
  
  ### Parse the input
  # Eliminate the first line and last line (extraneous)
  unparsed_data <- unparsed_data[-c(1, length(unparsed_data))]
  
  # Determine the number of plates
  plate_endings <- grep("^~End", unparsed_data)
  number_of_plates <- length(plate_endings)
  cat(paste("File ", file_name, ": found ",number_of_plates," plates' worth of plate data.\n", sep = ""))
  
  # Call function to get the data for each plate
  plate_data <- lapply(1:number_of_plates, 
                       function(x) {parse_individual_plate(unparsed_data, plate_endings[x], x)})
  
  # Combine into a single data frame
  plate_data <- dplyr::bind_rows(plate_data)
  
  return(plate_data)
}

# Description: for any table containing metadata, check if required columns exist and exit early if not.
check_metadata <- function(table_with_metadata, input_type) {
  # Input type is 'raw' (i.e., plain metadata) or 'pre-parsed' (i.e., plate data and metadata combined)
  
  # Define required columns based on input type
  if (input_type == "raw") {
    required_colnames <- c("Plate_number", "Well", "Sample_name", "Sample_type", 
                           "Blanking_group", "Dilution_factor", "Standard_conc")
  } else if (input_type == "pre-parsed") {
    required_colnames <- c("Plate_number", "Well", "Absorbance", "Sample_name", "Sample_type", 
                           "Blanking_group", "Dilution_factor", "Standard_conc")
  } else {
    stop("ERROR: input_type must be either 'raw' or 'pre-parsed'. Exiting...")
  }
  
  # Check if required columns exist. If they do not, exit early.
  req_col_test <- unique(required_colnames %in% colnames(table_with_metadata))
  if (length(req_col_test) != 1 | req_col_test[1] == FALSE) {
    stop(paste("ERROR: Missing at least one required table column; see README.md. You need at least: '", glue::collapse(required_colnames, sep = ", ") ,"'. Exiting...", sep = ""))
  }
  
}

# Description: adds sample metadata to the parsed absorbance data
add_sample_metadata <- function(plate_data, metadata_filename) {
  ## Import sample order data
  plate_order <- read.table(metadata_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
  
  # Check required columns exist and exit if not
  check_metadata(plate_order, input_type = "raw")
  
  ## Check if the sample naming and plate abosorbance data have the same number of plates, and throw a warning if not
  if (identical(unique(plate_order$Plate_number), unique(plate_data$Plate_number)) == FALSE) {
    warning("Number of plates in raw data files and sample naming sheet do not match. NA values will be placed where there are unmatched plates and may cause unexpected behaviour.")
  }
  
  ## Join sample order data with absorbance data
  plate_data_merged <- dplyr::full_join(plate_order, plate_data, by = c("Well","Plate_number"))
  
  # Move absorbance data to the third column
  # TODO - make this code cleaner and more generic (e.g., what if Absorbance is not the last column someday after a code modification?)
  plate_data_merged <- plate_data_merged[,c(1:2, ncol(plate_data_merged), 3:(ncol(plate_data_merged)-1))]
  
  return(plate_data_merged)
}

# Description: fully parses and integrates raw plate absorbance data and metadata
parse_raw_data <- function(plate_data_filename, sample_metadata_filename) {
  
  # Error if nothing provided for input
  if (length(plate_data_filename) == 0) {
    stop("ERROR: no input raw plate data file detected")
  }
  
  # Parse input file
  plate_data <- parse_input_file(plate_data_filename)
  
  # Add sample naming data
  plate_data_merged <- add_sample_metadata(plate_data, sample_metadata_filename)
  
  return(plate_data_merged)
  
}

# Description: generates summary stats for blanking group for each plate.
# Throws a warning if SD > 10% of mean
# MUST be one blank per plate for each group in that plate (good form)
summarize_blanks <- function(plate_table) {
  ### Summarize blanks
  blanks_raw <- filter(plate_table, Sample_type == "Blank")
  # Group by all variables supplied by user, in case this helps to split samples apart for the desired factorial approach
  blanks_grouped <- dplyr::group_by_at(blanks_raw, colnames(blanks_raw)[!(colnames(blanks_raw) %in% c("Well", "Absorbance", "Standard_conc"))])
  blanks_summ <- summarise(blanks_grouped, Blank_ave_abs = mean(Absorbance), Blank_stdDev_abs = sd(Absorbance))
  
  # Throw a warning if SD > 10% of mean
  for (i in 1:nrow(blanks_summ)) {
    if (blanks_summ$Blank_stdDev_abs[i] > (blanks_summ$Blank_ave_abs[i]) / 10) {
      warning(paste("Plate ", unique(plate_table$Plate_number), ": ", blanks_summ$Blanking_group[i], ": standard deviation is > 10% of mean of replicate blanks. Data could be fishy...", sep = ""))
    }
  }
  
  return(blanks_summ)
}

# Description: blanks the absorbances of all standards/samples
# Return: data table with the blanked absorbances as 'Absorbance_blanked' (column)
blank_absorbances <- function(plate_table, summarized_blanks) {
  
  # Remove selected columns from blank table ahead of time to avoid issues during the left join
  summarized_blanks$Sample_name <- NULL
  cols_to_remove <- c("Sample_name", "Replicate", "Sample_type", "Dilution_factor")
  cols_to_remove_logical <- !colnames(summarized_blanks) %in% cols_to_remove
  summarized_blanks <- summarized_blanks[,cols_to_remove_logical]
  
  # Join tables so that the blank absorbance is applied as a column for all entries with the same blanking group
  # Join by all columns except c("Blank_ave_abs", "Blank_stdDev_abs"), which will added to the blanked table
  non_join_cols_logical <- !(colnames(summarized_blanks) %in% c("Blank_ave_abs", "Blank_stdDev_abs"))
  join_cols <- colnames(summarized_blanks)[non_join_cols_logical]
  plate_table_blanked <- dplyr::left_join(plate_table, summarized_blanks, by = join_cols)
  
  # Blank the absorbances
  plate_table_blanked$Absorbance_blanked <- plate_table_blanked$Absorbance - plate_table_blanked$Blank_ave_abs
  
  # Now that blanking is done, remove unnecessary columns introduced during blanking
  plate_table_blanked$Blank_ave_abs <- NULL
  plate_table_blanked$Blank_stdDev_abs <- NULL
  
  return(plate_table_blanked)
  
}

# Description: checks std_summ to ensure everything looks okay. Can remove very low standards if below blank.
# Return: std_summ with possible removed standards (and throws a warning here)
check_standards <- function(std_summ, plate_table_blanked) {
  # Check if standards belong to more than one blanking group. Could imply that there are multiple types of standards in a single plate, which this script cannot handle.
  std_Blanking_group <- as.character(unique(std_summ$Blanking_group))
  
  # Check that only one Blanking Group is present and throw a warning otherwise -- handling multiple is not yet supported.
  if (length(std_Blanking_group) > 1) {
    warning(paste("Detected standards of multiple Blanking Groups in Plate ", 
                  unique(plate_table_blanked$Plate_number), ". the dataset. The script is not yet able to handle this. Should only be one type of standard per plate. Your data could be unusual...", sep = ""))
  }
  
  # Check if blank absorbance is greater than absorbance of lowest standard
  if (min(std_summ$Ave_abs_blanked) < 0) {
    # Identify number of standards below blank
    stds_below_blank <- dplyr::filter(std_summ, Ave_abs_blanked < 0)
    std_names_below_blank <- unique(stds_below_blank$Sample_name)
    std_names_below_blank_readable <- glue::collapse(std_names_below_blank, sep = ", ")
    
    # Throw a warning
    warning(paste("Plate_number ", unique(plate_table_blanked$Plate_number), ": blank has higher absorbance than ", nrow(stds_below_blank), 
                  " of the standards (",  std_names_below_blank_readable, "). Will throw out all standards below blank.", sep = ""))
    
    # Remove all standards with absorbance lower than blank
    std_summ <- dplyr::filter(std_summ, Ave_abs_blanked > 0)
  }
  
  return(std_summ)
}

# Description: checks if standard groups are present in the metadata, and adds standard groups otherwise (even if the same group for the whole dataset)
# Return: plate_table_blanked with 'Standard_group' column
check_standard_groups <- function(plate_table_blanked) {
  
  ### Summarize standard curve data
  std_raw <- dplyr::filter(plate_table_blanked, Sample_type == "Standard")
  # TODO - if proceeding with multi-standard support: change this to rely on core columns only but then allow for all other columns to impact grouping, in case the user wanted more than one group of standards
  # Group by all variables supplied by user, in case this helps to split standards apart for the desired factorial approach
  std_grouped <- dplyr::group_by_at(std_raw, colnames(std_raw)[!(colnames(std_raw) %in% c("Well", "Absorbance", "Absorbance_blanked"))])
  std_summ <- summarise(std_grouped, Ave_abs_blanked = mean(Absorbance_blanked), StdDev_abs_blanked = sd(Absorbance_blanked))
  
  # Reduce std_summ to make easier to compare standard names during the check
  # NOTE: DO NOT return std_summ to user because of this! Will be uninformative.
  cols_to_omit_in_check <- c("Ave_abs_blanked", "StdDev_abs_blanked")
  std_summ <- std_summ[,!(colnames(std_summ) %in% cols_to_omit_in_check)]
  
  if (("Standard_group" %in% colnames(plate_table_blanked)) == TRUE) {
    
    cat("Detected column 'Standard_group' in input metadata for handling multiple standards.\n")
    
  } else if (length(unique(std_summ$Sample_name)) == length(std_summ$Sample_name)) {
    
    # Else, see if just one standard type exists after summary
    cat("One set of standards detected in entire input file.\n")
    
    # Add Standard_group for whole plate
    plate_table_blanked$Standard_group <- 1
  
  } else if (length(unique(plate_table_blanked$Plate_number)) > 1 && 
             length(unique(std_summ$Sample_name)) == nrow(unique(std_summ[,!(colnames(std_summ) %in% "Plate_number")])) &&
             unique(plate_table_blanked$Plate_number) == unique(std_summ$Plate_number)) {
    # Else, if the input file contained more than one plate, see if there is one standard per plate
    # Check this by seeing if three conditions are true:
    # 1. There is more than one plate in the input file
    # 2. The number of unique entries in the std_summ table after removing Plate_number matches the number of unique standards defined by Sample_name
    # TODO - see if #2 can be done more elegantly
    # 3. There is at least one standard present on each plate in the input data
    
    cat("One set of standards detected per plate in the input file. Will calculate a separate standard curve for each plate.\n")
    
    # Add standard group identical to Plate_number
    plate_table_blanked$Standard_group <- plate_table_blanked$Plate_number
    
  } else if (length(unique(std_summ$Sample_name)) < length(std_summ$Sample_name)) {
    # If there are extra standard groups on each plate, then error out
    
    stop("You appear to have multiple types of standards on each plate but have not supplied the 'Standard_group' column in your metadata file. The script cannot determine which samples to apply the different types of standards to. Please add the 'Standard_group' column and try again. Exiting...")
    
  } else {
    stop("Something odd and unexpected went wrong in 'check_standard_groups'...")
  }
  
  return(plate_table_blanked)
  
}

# Description: determines standard curve for a provided standard_group
calculate_standard_curve <- function(plate_table_blanked, standard_group) {
  
  ## Summarize standard curve data for the standard_group of interest
  std_raw <- dplyr::filter(plate_table_blanked, Sample_type == "Standard" & Standard_group == standard_group)
  # Group by all variables supplied by user, in case this helps to split standards apart for the desired factorial approach
  std_grouped <- dplyr::group_by_at(std_raw, colnames(std_raw)[!(colnames(std_raw) %in% c("Well", "Absorbance", "Absorbance_blanked"))])
  std_summ <- summarise(std_grouped, Ave_abs_blanked = mean(Absorbance_blanked), StdDev_abs_blanked = sd(Absorbance_blanked))
  
  # Run check of standards and remove negative absorbance standards if needed
  std_summ <- check_standards(std_summ, plate_table_blanked)
  
  # Make linear trendline
  if (force_curve_through_zero == TRUE) {
    trendline <- lm(Ave_abs_blanked ~ 0 + Standard_conc, data = std_summ)
    # Forcing through origin: https://stackoverflow.com/a/18947967, accessed 170815
  } else {
    trendline <- lm(Ave_abs_blanked ~ Standard_conc, data = std_summ)
  }
  
  # Summarize key trendline values
  if (force_curve_through_zero == TRUE) {
    trendline_coeff <- c(0, coefficients(trendline)) # to make this match what the coefficients look like when not fixed to origin
  } else {
    trendline_coeff <- coefficients(trendline)
  }
  trendline_Rsquared <- summary(trendline)$r.squared
  trendline_summ <- data.frame("Intercept" = unname(trendline_coeff[1]), "Slope" = unname(trendline_coeff[2]), 
                               "R_squared" = trendline_Rsquared, "Plate_number" = unique(std_summ$Plate_number), 
                               "Standard_group" = unique(std_summ$Standard_group), stringsAsFactors = FALSE)
  
  # Return list of processed data
  std_curve_summary <- list(std_summ, trendline_summ)
  names(std_curve_summary) <- c("summarized_standards", "summarized_trendline")
  
  return(std_curve_summary)
}

# Description: summarizes unknowns by all metadata categories provided by user for a standard_group
summarize_unknowns <- function(plate_table_blanked, standard_group) {
  
  ## Summarize standard curve data
  unk_raw <- dplyr::filter(plate_table_blanked, Sample_type == "Unknown" & Standard_group == standard_group)
  # Group by all variables supplied by user, in case this helps to split samples apart for the desired factorial approach
  unk_grouped <- dplyr::group_by_at(unk_raw, colnames(unk_raw)[!(colnames(unk_raw) %in% c("Well", "Absorbance", "Absorbance_blanked", "Standard_conc"))])
  # unk_grouped <- group_by(unk_raw, Blanking_group, Treatment, Sample_name, Dilution_factor, Plate_number, Replicate)
  summarized_unknowns <- dplyr::summarise(unk_grouped, Ave_abs_blanked = mean(Absorbance_blanked), StdDev_abs_blanked = sd(Absorbance_blanked))
  
  # Throw a warning if the blanking group does not exist for an unknown.
  if (anyNA(summarized_unknowns$Ave_abs_blanked) == TRUE) {
    # TODO - add code to determine the exact blanking group that is missing
    warning(paste("Plate ", unique(plate_table_blanked$Plate_number), ": at least one blanking group for unknowns has no corresponding blank. Data will contain NA values.", sep = ""))
  }
  
  return(summarized_unknowns)
}

# Description: checks concentration data for a single standard_group and makes minor modifications specifically 
             # for plot aesthetics (e.g., no error bars below zero on log scale!)
# Return: summarized_unknowns_plotting_data (i.e., data table specifically for plotting)
check_concentrations <- function(summarized_unknowns) {
  # Throw a warning if some concentrations are negative
  if (min(summarized_unknowns$Ave_concentration) <= 0) {
    neg_values_positions <- which(summarized_unknowns$Ave_concentration <= 0)
    neg_values <- summarized_unknowns$Ave_concentration[neg_values_positions]
    num_neg_values <- length(neg_values)
    neg_values_readable <- glue::collapse(round(neg_values, 3), sep = ", ")
    
    # TODO - omit this entirely?    
    # # Omit those from standard curve plotting data frame (but keep in the unknowns data)
    # summarized_unknowns_plotting_data <- summarized_unknowns[-neg_values_positions,]
    
    # Report what was done
    if (num_neg_values == 1) {
      warning("Plate_number ", unique(summarized_unknowns$Plate_number), ": ", num_neg_values, " sample has a negative concentration based on standard curve (",
              glue::collapse(round(neg_values, 3), sep = ", "), ").", sep = "")
    } else if (num_neg_values > 1) {
      warning("Plate_number ", unique(summarized_unknowns$Plate_number), ": ", num_neg_values, " samples have negative concentrations based on standard curve (",
              neg_values_readable, ").", sep = "")
    }
    
    # (Probably rare:) Check if negative absorbances remain even after removing negative concentrations
    if (min(summarized_unknowns_plotting_data$Ave_abs_blanked) < 0) {
      neg_abs_positions <- which(summarized_unknowns_plotting_data$Ave_abs_blanked <= 0)
      
      warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": also note that ", num_neg_values, " additional samples have positive concentrations but negative blanked absorbances... something could be odd with the data.", sep = ""))
    }
    
  } else {
    # No issues with negative concentrations.
    # TODO - omit making this secondary data table if I end up choosing to never omit values from the plot.
    summarized_unknowns_plotting_data <- summarized_unknowns
  }
  
  # Generate error bar values in plotting data frame ahead of time and see if any are below zero (will cause error due to log scale)
  summarized_unknowns_plotting_data$errorbar_min <- summarized_unknowns_plotting_data$Ave_abs_blanked - summarized_unknowns_plotting_data$StdDev_abs_blanked
  summarized_unknowns_plotting_data$errorbar_max <- summarized_unknowns_plotting_data$Ave_abs_blanked + summarized_unknowns_plotting_data$StdDev_abs_blanked
  
  if (min(summarized_unknowns_plotting_data$errorbar_max) < 0) {
    # Max error bar should not be < 0 at this point, because negative data points for concentration were already removed
    warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": something seems wrong with the error bars on samples in the standard curve plots...", sep = ""))
    
  } else if (min(summarized_unknowns_plotting_data$errorbar_min) < 0) {
    # Eliminate negative values and replace with the value of the point itself (so bottom bars will essentially be unplotted)
    neg_errorbar_pos <- which(summarized_unknowns_plotting_data$errorbar_min < 0)
    summarized_unknowns_plotting_data$errorbar_min[neg_errorbar_pos] <- summarized_unknowns_plotting_data$Ave_abs_blanked[neg_errorbar_pos]
    
    warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": had to remove negative min. error bar positions for ", length(neg_errorbar_pos), 
                  " sample(s) in the std. curve plot in order to make the sample(s) plot-able. Unchanged in the actual data, however...", sep = ""))
  }
  
  return(summarized_unknowns_plotting_data)
}

# Description: creates standard curve plots for a single standard_group
# Return: list of two types of plots (with and without unknowns added)
plot_standard_curve <- function(std_curve_summary, summarized_unknowns_plotting_data) {
  # Figure out where to put the trend line equation text on the plot
  min_x <- min(std_curve_summary$summarized_standards$Standard_conc)
  max_x <- max(std_curve_summary$summarized_standards$Standard_conc)
  min_y <- min(std_curve_summary$summarized_standards$Ave_abs_blanked)
  max_y <- max(std_curve_summary$summarized_standards$Ave_abs_blanked)
  # TODO - pull these out to the top of the script?
  x_coord <- (max_x - min_x) * 0.05 # arbitrary position 5% to the right of the y axis
  y_coord <- (max_y - min_y) * 0.8 # arbitrary position 80% above the x axis
  
  ## Make standards plot without samples
  std_plot <- ggplot(std_curve_summary$summarized_standards, aes(x = Standard_conc, y = Ave_abs_blanked)) +
    geom_smooth(method = "lm", formula = "y ~ x", se = TRUE, colour = "purple") +
    geom_errorbar(aes(x = Standard_conc, ymin = Ave_abs_blanked-StdDev_abs_blanked, 
                      ymax = Ave_abs_blanked+StdDev_abs_blanked), width = 0, size = 0.8, alpha = 0.8) +
    geom_point(alpha = 0.9, size = 3) +
    annotate("text", x = x_coord, y = y_coord, 
             label = paste("y = ", round(std_curve_summary$summarized_trendline$Slope, digits = 5), 
                           "x + ", round(std_curve_summary$summarized_trendline$Intercept, digits = 5), 
                           "\n R^2 = ", round(std_curve_summary$summarized_trendline$R_squared, digits = 5), sep = ""), size = 3) +
    theme_bw() +
    # Add theme elements to make the plot look nice
    theme(panel.grid = element_blank(), title = element_text(size = 10), axis.title = element_text(size = 12), 
          strip.text = element_text(size = 10), strip.background = element_rect(fill = "#e6e6e6"),
          panel.border = element_rect(colour = "black", size = 1), panel.spacing.y = unit(3, "mm"), panel.spacing.x = unit(0, "mm"),
          axis.text.x = element_text(size = 10, colour = "black"), axis.text.y = element_text(size = 10, colour = "black"),
          axis.ticks = element_line(size = 0.5), axis.line = element_line(colour = "black", size = 0.5),
          legend.text = element_text(size = 7), legend.title = element_blank(),
          legend.key = element_rect(colour = "grey", size = 0.3), legend.key.size = unit(3, "mm"),
          legend.spacing = unit(1, "mm"), legend.box.just = "left", plot.margin = unit(c(2,2,2,2), "mm")) +
    #         See http://stackoverflow.com/questions/1330989/rotating-and-spacing-axis-labels-in-ggplot2 (approx. Jan 27, 2016) for vertical x-axis labels
    # scale_x_continuous(limits = c(0, NA)) +
    # scale_y_continuous(limits = c(0, NA)) +
    scale_x_log10() +
    scale_y_log10() +
    annotation_logticks() +
    xlab(paste("Concentration (", unique(summarized_unknowns_plotting_data$Concentration_units), ")", sep = "")) +
    ylab("Absorbance (blanked)") +
    ggtitle(paste("Plate_number: ", unique(summarized_unknowns_plotting_data$Plate_number), sep = ""))
  
  # Add on samples to the standard plot
  # Divide by dilution factor to make them place properly
  unk_plot <- std_plot +
    geom_errorbar(data = summarized_unknowns_plotting_data, 
                  aes(x = (Ave_concentration / Dilution_factor), 
                      ymin = errorbar_min, ymax = errorbar_max), 
                  width = 0, size = 0.8, alpha = 0.8, colour = "darkcyan") +
    geom_point(data = summarized_unknowns_plotting_data, 
               aes((Ave_concentration / Dilution_factor), Ave_abs_blanked), 
               shape = 21, alpha = 0.8, size = 3, fill = "darkcyan")
  
  output_plots <- list(std_plot, unk_plot)
  names(output_plots) <- c("std_curve_plot", "std_curve_plot_with_unknowns")
  
  return(output_plots)
  
}

# Description: converts sample absorbances to concentrations for a standard_group
convert_to_concentration <- function(summarized_unknowns, std_curve_summary) {
  
  # Convert to concentration using standard curve (linear model) AND dilution factor
  summarized_unknowns$Ave_concentration <- ((summarized_unknowns$Ave_abs_blanked - 
                                              std_curve_summary$summarized_trendline$Intercept) / 
                                              std_curve_summary$summarized_trendline$Slope * 
                                              summarized_unknowns$Dilution_factor)
  
  # Get standard devations (also accounting for dilution factor)
  summarized_unknowns$StdDev_concentration <- ((summarized_unknowns$StdDev_abs_blanked / 
                                                 std_curve_summary$summarized_trendline$Slope) * 
                                                 summarized_unknowns$Dilution_factor)
  # For calculating std dev like this, see http://www.psychstat.missouristate.edu/introbook/sbk15.htm, accessed ~Jan. 2017
  
  # TODO - add a setting to toggle this for the user.
  summarized_unknowns$Concentration_units <- "uM"
  
  # Check concentration data and make minor modifications to improve plot readability (not affecting actual data) if needed
  summarized_unknowns_plotting_data <- check_concentrations(summarized_unknowns)
  
  # Make standard curve plots
  std_curve_plots <- plot_standard_curve(std_curve_summary, summarized_unknowns_plotting_data)
  
  output_list <- list(summarized_unknowns, std_curve_plots$std_curve_plot, std_curve_plots$std_curve_plot_with_unknowns)
  names(output_list) <- c("calculated_concentrations", "std_plot", "std_plot_with_unknowns")
  # TODO - make list names consistent with above function
  return(output_list)
  
}

# Description: calculates standard curve and concentration for a given standard_group
# Return: list of five: summarized_standards; summarized_trendline; summarized_unknowns with concentrations
        # standard curve plot; standard curve plot with unknowns
# Depends: calculate_standard_curve; summarize_unknowns; convert_to_concentration
calculate_standard_group <- function(plate_table_blanked, standard_group) {
  
  # Get trendline and summarized standards within the standard_group
  std_curve_summary <- calculate_standard_curve(plate_table_blanked, standard_group)
  
  # Get unknowns matching the standard_group
  summarized_unknowns <- summarize_unknowns(plate_table_blanked, standard_group)
  
  # Convert those unknowns to a concentration and make plots
  # TODO - long-term, consider making separate functions for plotting versus summarizing unknowns
  calculated_concentrations <- convert_to_concentration(summarized_unknowns, std_curve_summary)
  
  # Make a new list with the output for that standard_group - sort items close to the desired final output order
  output_list <- list(calculated_concentrations$calculated_concentrations, std_curve_summary$summarized_standards, 
                      std_curve_summary$summarized_trendline, calculated_concentrations$std_plot,
                      calculated_concentrations$std_plot_with_unknowns)
  # TODO - consider hard-coding this somewhere at the top
  names(output_list) <- c("Unknowns", "Standards", "Trendlines", "Std_curve_plot", "Std_curve_plot_with_unknowns")
  
  return(output_list)
  
}

# Description: Given a nested list with identical structure across level 1, moves the list item of identical 
             # name or position from all lists into their own primary list
subset_list <- function(plate_data_calculated, item) {
  
  similar_items <- lapply(names(plate_data_calculated), 
                          function(x) { return(plate_data_calculated[[x]][[item]])})
  names(similar_items) <- names(plate_data_calculated)
  
  return(similar_items)
}

# Description: if a list is composed of data frames, bind them together using dplyr::bind_rows
# Return: the input list, bound if composed of data frames
collapse_list <- function(input_list) {
  if (is.data.frame(input_list[[1]]) == TRUE) {
    # If first list entry is a data frame, assume all in list are data frames based on how this script was written
    # TODO - make this more robust
    
    # Collapse to single table
    input_list <- dplyr::bind_rows(input_list)
  }
  
  return(input_list)
}

# Description: creates a 96 well plate-style figure of the parsed data, for the specified plate_number
make_plate_diagram <- function(plate_table, plate_number) {
  
  # Get data from that plate_number
  plate_table <- dplyr::filter(plate_table, Plate_number == plate_number)
  
  # Split wells into row and column
  plate_table$Well_row <- as.character(substr(plate_table$Well, start = 1, stop = 1))
  plate_table$Well_col <- as.numeric(substr(plate_table$Well, start = 2, stop = 3))
  
  # Make table of all wells in a 96 well plate to merge with main table
  # (in case some wells have been omitted by the user from the main table; this way, the entire 96 well plate will appear in the figure)
  wells_96 <- data.frame("Well_row" = c(rep("A", 12), rep("B", 12), rep("C", 12), rep("D", 12), rep("E", 12), rep("F", 12), rep("G", 12), rep("H", 12)),
                         "Well_col" = rep(c(1:12), 8), stringsAsFactors = FALSE)
  
  # Merge tables
  plate_table <- dplyr::full_join(plate_table, wells_96, by = c("Well_row", "Well_col"))
  
  # Put rows in order
  plate_table$Well_row <- factor(plate_table$Well_row, levels = rev(c("A", "B", "C", "D", "E", "F", "G", "H")), ordered = TRUE)
  
  # Make annotation text
  plate_table$Annotation <- paste(plate_table$Sample_name, " ", plate_table$Replicate, "\n", plate_table$Absorbance, sep = "")
  # Clean out ones with no sample
  for (i in 1:length(plate_table$Annotation)) {
    if (plate_table$Sample_name[i] == "" | is.na(plate_table$Sample_name[i]) == TRUE) {
      plate_table$Annotation[i] <- ""
    }
  }
  
  plate_diagram <- ggplot(plate_table, aes(factor(Well_col), Well_row)) +
    geom_point(aes(fill = Absorbance), shape = 21, size = 18) +
    geom_text(aes(label = Annotation), size = 2) +
    scale_fill_gradientn(colours = c("#ffffff", "#ff3399", "#660066"), limits = c(0,1)) + # Used limits to set absolute colour scale, as recommended at https://stackoverflow.com/a/21538521 (accessed Oct 2nd, 2017)
    xlab("") +
    ylab("") +
    ggtitle(unique(plate_table$Date))
  
  return(plate_diagram)
}

# Description: fully processes calculation data for a single input file (for all standard_groups)
# MASTER FUNCTION for calculation section
# Return: list of seven: raw data for input file; blanks; standards; trendlines; unknowns; std_curve_plot; std_curve_plot_with_unknowns
# Depends: summarize_blanks; blank_absorbances; check_standard_groups; calculate_standard_group; subset_list; collapse_list
calculate_plate_data <- function(plate_table) {
  
  # Blank the absorbances
  summarized_blanks <- summarize_blanks(plate_table)
  plate_table_blanked <- blank_absorbances(plate_table, summarized_blanks)
  
  # Group into standard_groups (add if missing ormaybe error out)
  plate_table_blanked <- check_standard_groups(plate_table_blanked)
  
  # Process data for each standard group
  calculated_data_per_std_grp <- lapply(unique(plate_table_blanked$Standard_group), 
         function(x) {calculate_standard_group(plate_table_blanked, standard_group = x)})
  names(calculated_data_per_std_grp) <- unique(plate_table_blanked$Standard_group)
  
  # Re-arrange output for clarity into one list per item type (rather than one list per standard_group)
  separated_list_entries <- lapply(names(calculated_data_per_std_grp[[1]]), 
                                   function(x) { subset_list(calculated_data_per_std_grp, item = x) })
  names(separated_list_entries) <- names(calculated_data_per_std_grp[[1]])
  
  # Bind each list of tables together into a single table
  bound_list_entries <- lapply(1:length(separated_list_entries), 
                               function(x) { collapse_list(input_list = separated_list_entries[[x]])})
  names(bound_list_entries) <- names(separated_list_entries)
  
  # Add the summarized blanks and blanked raw data to the exported list
  output_list <- c(list(plate_table, summarized_blanks), bound_list_entries)
  names(output_list) <- c("Raw_data", "Blanks", names(bound_list_entries))
  
  # Re-order list based on desired final output order
  # NOTE: names provided here must exactly match names of list entries
  list_order <- c("Raw_data", "Unknowns", "Blanks", "Standards", "Trendlines", "Std_curve_plot", "Std_curve_plot_with_unknowns")
  output_list <- output_list[list_order]
  
  return(output_list)
  
}

# Description: writes Excel table of summarized data
write_excel_table <- function(output_filenames_prefix, summarized_table_list) {
  
  table_sheetnames <- names(summarized_table_list)
  
  # Save as Excel workbook with multiple sheets
  xlsx_table_filename <- paste(output_filenames_prefix, "_calculations.xlsx", sep = "")
  for (i in 1:length(summarized_table_list)) {
    if (i == 1) {
      write.xlsx2(as.data.frame(summarized_table_list[[i]]), xlsx_table_filename, 
                  sheetName = table_sheetnames[[i]], col.names=TRUE, row.names=FALSE, append=FALSE)
    } else {
      write.xlsx2(as.data.frame(summarized_table_list[[i]]), xlsx_table_filename, 
                  sheetName = table_sheetnames[[i]], col.names=TRUE, row.names=FALSE, append=TRUE)
    }
  }
  
}

# Description: prints a single PDF file with all plots in the input list (item_name within summarized_plot_list)
print_plot_file <- function(output_filenames_prefix, summarized_plot_list, item_name) {
  
  plot_filename <- paste(output_filenames_prefix, "_", item_name, ".pdf", sep = "")
  
  # TODO - make this more elegant
  if (item_name == "Plate_diagrams") {
    pdf(file = plot_filename, width = 10, height = 6)
  } else if (item_name != "Plate_diagrams") {
    pdf(file = plot_filename, width = 7, height = 7)
  }
  
  print(summarized_plot_list[[item_name]])
  # See https://stackoverflow.com/a/29834646, accessed 170815
  dev.off()
  
}

main <- function() {
  # Run command line version if requested
  if (RUN_COMMAND_LINE == TRUE) {
    parse_command_line_input()
  } else {
    
    # Like done in parse_command_line_input, determine if the inputs are pre-parsed or not
    if ((is.null(plate_data_filename) == FALSE | is.null(sample_metadata_filename) == FALSE) && is.null(pre_parsed_data_file) == FALSE ) {
      # Quit if -i or -m AND -p were simultaneously set
      stop("ERROR: Cannot have the '-p' flag set at the same time as '-i' or '-m'. Exiting...")
    } else if (is.null(pre_parsed_data_file) == FALSE) {
      input_mode <- "pre-parsed"
    } else if (is.null(plate_data_filename) == FALSE && is.null(sample_metadata_filename) == FALSE) {
      input_mode <- "raw"
    } else if (is.null(plate_data_filename) == FALSE | is.null(sample_metadata_filename) == FALSE) {
      # If both -i and -m were not set together (checked in previous if statement), then exit if at least one of them was selected (means that the other one was not)
      stop("ERROR: Need to have both '-i' and '-m' set to run in raw input mode. See -h for details. Exiting...")
    } else {
      stop("Something unexpected went wrong related to the '-p', '-i', and '-m' flags being set improperly. Exiting...")
    }
    
  }
  
  # Assign default naming prefix if not assigned by user
  if (is.na(output_filenames_prefix) == TRUE | is.null(output_filenames_prefix) == TRUE) {
    output_filenames_prefix <- substr(plate_data_filename[1], 1, nchar(plate_data_filename[1])-4)
  }
  
  # Startup messages
  cat(paste("Running 96_well_spec_analysis.R, version: ", SCRIPT_VERSION, "\n\n", sep = ""))
  if (input_mode == "raw") {
    cat(paste("Plate data filename:", plate_data_filename, "\n"))
    cat(paste("Metadata filename:", sample_metadata_filename, "\n"))
    cat(paste("Pre-parsed plate data filename:", "NOT APPLICABLE", "\n"))
  } else if (input_mode == "pre-parsed") {
    cat(paste("Plate data filenames:", "NOT APPLICABLE", "\n"))
    cat(paste("Metadata filename:", "NOT APPLICABLE", "\n"))
    cat(paste("Use pre-parsed plate data instead?:", pre_parsed_data_file, "\n"))
  }
  cat(paste("Prefix for output files:", output_filenames_prefix, "\n"))
  cat(paste("Force standard curves through zero?:", force_curve_through_zero, "\n"))
  cat("\n")
  
  ##### Import plate data
  # Take different courses of action depending on whether input_mode is 'raw' or 'pre-parsed'
  if (input_mode == "raw") {
    
    cat("Parsing plate data...\n")
    plate_table <- parse_raw_data(plate_data_filename, sample_metadata_filename)
    
    # Export combined data
    merged_data_filename <- paste(output_filenames_prefix, "_raw_data.tsv", sep = "")
    write.table(plate_table, file = merged_data_filename, sep = "\t", col.names = TRUE, row.names = FALSE)
    
  } else if (input_mode == "pre-parsed") {
    
    # Read in pre-merged plate/sample data
    cat("Loading pre-parsed data table...\n")
    plate_table <- read.table(pre_parsed_data_file, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
    
    # Check required columns exist and exit if not
    check_metadata(plate_table, input_type = "pre-parsed")
    
  }
  
  ##### Process standards and unknowns
  cat("Calculating concentrations...\n")
  calculated_plate_data <- calculate_plate_data(plate_table)
  
  # Make plate diagrams
  plate_diagrams <- lapply(unique(plate_table$Plate_number), 
         function(x) { make_plate_diagram(plate_table, plate_number = x) })
  names(plate_diagrams) <- unique(plate_table$Plate_number)
  
  # Summarize as list for combining into the summarized_plot_list later
  plate_diagrams <- list(plate_diagrams)
  names(plate_diagrams) <- "Plate_diagrams"
  
  ##### Summarize output
  cat("Summarizing output...\n")
  
  # Make separate list of tables only and plots only (manually!)
  summarized_table_list <- calculated_plate_data[c(1:5)]
  summarized_plot_list <- c(calculated_plate_data[c(6:7)], plate_diagrams)
  
  cat("Printing summary files...\n")
  # Write summary Excel table
  write_excel_table(output_filenames_prefix, summarized_table_list)
  
  # Also export unknowns as TSV
  table_filename_unknowns <- paste(output_filenames_prefix, "_unknowns.tsv", sep = "")
  write.table(summarized_table_list$Unknowns, file = table_filename_unknowns, sep = "\t", 
              col.names = TRUE, row.names = FALSE)
  
  # Print plots
  lapply(names(summarized_plot_list), function(x) { print_plot_file(output_filenames_prefix, 
                                                                    summarized_plot_list, x)})
  
  cat("\n96_well_spec_analysis.R: finished.\n\n")
  
}

main()
