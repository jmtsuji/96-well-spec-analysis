#!/usr/bin/env RScript
# 96 well spectrophotometer data analysis
# Copyright Jackson M. Tsuji (Neufeld Lab PhD student), 2018
# Created Nov 10th, 2016
# Description: Imports and processes data from the Neufeld lab 96 well plate reader

#####################################################
## User variables: #################################
RUN_COMMAND_LINE <- TRUE # If selected, all user input here is ignored, and terminal-based input is expected instead.

# Set other user variables here
if (RUN_COMMAND_LINE == FALSE) {
  setwd("/Users/JTsuji/Research_General/Bioinformatics/02_git/96-well-spec-analysis/") # your working directory where files are stored
  parse_raw_plate_data <- TRUE # Set TRUE if you need to parse raw plate data. Will parse, then exit.
  plate_data_filename <- c("testing/input/example_raw_plate_data_1.txt", "testing/input/example_raw_plate_data_2.txt") # Add in a vector if using multiple filenames
  # If parse_raw_plate_data == FALSE, then this should be COMBINED plate and sample order data as output by this script when parsing
  sample_metadata_filename <- "testing/input/example_sample_metadata.tsv" # Not needed if parse_raw_plate_data == FALSE
  force_zero <- TRUE # force the standard curve plots to go through (0,0)? (Recommended TRUE)
}

#####################################################
## Load required packages: ##########################
# TODO - add check function to see if these have been installed, and exit if not
library(getopt)
library(plyr)
library(dplyr)
library(ggplot2)
library(grid)
library(reshape2)
library(xlsx)
library(glue)
#####################################################

SCRIPT_VERSION <- "v0.3" # to match git tag

parse_command_line_input <- function() {
  ### Grab arguments
  # Arguments required:
  # -i input plate_data_filename
  # -m input sample_metadata_filename
  # -p parse_raw_plate_data
  # -z force_zero
  # -o output_filenames_prefix (for output files)
  params <- matrix(c('plate_data_filenames', 'i', 1, "character",
                     'sample_metadata_filename', 'm', 1, "character",
                     'parse_raw_plate_data', 'p', 2, "character",
                     'force_zero', 'z', 2, "character",
                     'output_filenames_prefix', 'o', 2, "character",
                     'help', 'h', 2, "character"), byrow=TRUE, ncol=4)
  
  opt <- getopt(params)
  
  # If help was called, print help message and exit
  if ( !is.null(opt$help) ) {
    
    cat("96_well_spec_analysis.R: Analyzed 96 well spec data generated by the Neufeld lab's plate reader.\n")
    cat("Copyright Neufeld Lab, 2018\n")
    cat("Contact Jackson M. Tsuji (jackson.@uwaterloo.ca) for bug reports or feature requests.\n")
    cat(paste("Version: ", SCRIPT_VERSION, "\n\n", sep = ""))
    
    cat(getopt(params, usage = TRUE))
    
    cat("\n")
    
    # TODO - add these details
    # cat("Details:\n", "-atlas_table\t\t\tFilepath for TSV-format ATLAS annotations table. [Required]\n",
    #     "-featureCounts_table\t\tFilepath for TSV-format featureCounts count file. [Required]\n",
    #     "-output_file\t\t\tFilepath for output TSV-format annotations file. [Required]\n\n")
    
    quit(status = 1)
  }
  
  # Exit if required inputs are not provided
  if ( is.null(opt$plate_data_filenames) ) {
    stop("Input plate data filepaths required. Try -h for help message.")
  }
  if ( is.null(opt$sample_metadata_filename) ) {
    stop("Input sample metdata filepath required. Try -h for help message.")
  }
  
  # Provide defaults for optional inputs if not provided
  if ( is.null(opt$parse_raw_plate_data) ) {
    opt$parse_raw_plate_data <- TRUE
  }
  if ( is.null(opt$force_zero) ) {
    opt$force_zero <- TRUE
  }
  if ( is.null(opt$output_filenames_prefix) ) {
    opt$output_filenames_prefix <- NA # Signal to determine properly later
  }
  
  # Make variables from provided input and save as global variables (<<-)
  # TODO - make CAPS
  plate_data_filename <<- opt$plate_data_filenames
  sample_metadata_filename <<- opt$sample_metadata_filename
  parse_raw_plate_data <<- opt$parse_raw_plate_data
  force_zero <<- opt$force_zero
  output_filenames_prefix <<- opt$output_filenames_prefix
  
}


# Description: parses one plate from an input file
parse_individual_plate <- function(unparsed_plate_data, plate_ending_line, plate_num) {
  # test data
  # unparsed_plate_data <- unparsed_data
  # plate_ending_line <- plate_endings[1]
  # plate_num <- 1
  
  # Get the lines where the absorbance and well data is kept for the plate
  plate_lines <- c((plate_ending_line - 2), (plate_ending_line -1))
  
  # Pull the lines from the unparsed file
  plate_unparsed <- unparsed_plate_data[plate_lines]
  
  # Eliminate the first two tabs
  plate_unparsed <- gsub("^\t\t", "", plate_unparsed)
  
  # Make a table out of the absorbance data
  plate_parsed <- strsplit(plate_unparsed, "\t")
  names(plate_parsed) <- c("Well", "Absorbance")
  plate_parsed$Absorbance <- as.numeric(plate_parsed$Absorbance)
  plate_parsed <- data.frame("Plate_number" = plate_num, 
                             "Well" = plate_parsed[[1]], 
                             "Absorbance" = plate_parsed[[2]], 
                             stringsAsFactors = FALSE)
  
  return(plate_parsed)
}

# Description: loads one input file (can contain multiple plates)
parse_input_file <- function(file_name) {
  # Internal dependency functions: 'parse_individual_plate'
  
  # Read the vectorized input - got code here from the readLines help file
  con <- file(file_name, encoding = "UTF-16LE") # Assumed encoding based on the output of the plate reader software
  # TODO - try to detect this (or throw an error if it doesn't work?)
  unparsed_data <- readLines(con)
  close(con)
  # unique(Encoding(A))
  
  ### Parse the input
  # Eliminate the first line and last line (extraneous)
  unparsed_data <- unparsed_data[-c(1, length(unparsed_data))]
  
  # Determine the number of plates
  plate_endings <- grep("^~End", unparsed_data)
  number_of_plates <- length(plate_endings)
  cat(paste("File ", file_name, ": found ",number_of_plates," plates' worth of plate data.\n", sep = ""))
  
  # Call function to get the data for each plate
  plate_data <- lapply(1:number_of_plates, 
                       function(x) {parse_individual_plate(unparsed_data, plate_endings[x], x)})
  
  # Combine into a single data frame
  plate_data <- dplyr::bind_rows(plate_data)
  
  return(plate_data)
}

# Description: merges all absorbance data into a single table
# (requires plate numbering adjustments)
merge_input_files_data <- function(all_plates_list) {
  # Internal dependency functions: none
  
  # Determine total number of plates and renumber plates to match
  # Start with an empty vector and add plates in a loop
  total_plate_number <- 0
  for (i in 1:length(all_plates_list)) {
    # Test data
    # i <- 1
    
    # Get the plate number up to this point in the loop
    current_plate_number <- total_plate_number
    
    # Get the numbers of the plates from the file being examined
    plate_nums <- unique(all_plates_list[[i]]$Plate_number)
    plates_in_file <- length(plate_nums)
    
    # Determine new plate numbers to assign based on current position in the loop
    new_plate_nums <- seq(from = (current_plate_number + 1), to = (current_plate_number + plates_in_file))
    
    # Re-number the plates in that plate file
    all_plates_list[[i]]$Plate_number <- plyr::mapvalues(all_plates_list[[i]]$Plate_number, from = plate_nums, to = new_plate_nums)
    
    # Add to the total number of plates
    total_plate_number <- total_plate_number + plates_in_file
  }
  
  all_plate_data <- dplyr::bind_rows(all_plates_list)
  
  # Check number of plates found in 'for loop' matches the number evident after merging
  final_plate_number <- length(unique(all_plate_data$Plate_number))
  if (total_plate_number != final_plate_number) {
    stop("ERROR: problem encountered in plate renumbering during file import. Exiting out.")
  } else {
    cat(paste("Imported data from a total of ", final_plate_number, " plate(s).\n", sep = ""))
  }
  
  return(all_plate_data)
}

# Description: adds sample metadata to the parsed absorbance data
# TODO - change this so that there is one metadata sheet for each plate input file, to avoid confusion.
add_sample_metadata <- function(all_plate_data, metadata_filename) {
  ## Import sample order data
  plate_order <- read.table(metadata_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
  
  # Check if required columns exist. If they do not, exit early.
  required_colnames <- c("Plate_number", "Well", "Sample_name", "Replicate", "Sample_type", "Treatment", "Blanking_group", "Dilution_factor", "Standard_conc")
  req_col_test <- unique(required_colnames %in% colnames(plate_order))
  if (length(req_col_test) != 1 | req_col_test[1] == FALSE) {
    stop("ERROR: Missing required column in sample naming file (see README.md). Exiting...")
  }
  
  ## Check if the sample naming and plate abosorbance data have the same number of plates, and throw a warning if not
  if (identical(unique(plate_order$Plate_number), unique(all_plate_data$Plate_number)) == FALSE) {
    warning("Number of plates in raw data files and sample naming sheet do not match. NA values will be placed where there are unmatched plates and may cause unexpected behaviour.")
  }
  
  ## Join sample order data with absorbance data
  all_plate_data_merged <- dplyr::full_join(all_plate_data, plate_order, by = c("Well","Plate_number"))
  
  return(all_plate_data_merged)
}

# Description: fully parses and integrates raw plate absorbance data and metadata
parse_raw_data <- function(plate_data_filename, sample_metadata_filename) {
  
  # Determine number of files provided
  number_of_files <- length(plate_data_filename)
  if (number_of_files == 1) {
    cat(paste("Loading data from ", number_of_files, " file...\n", sep = ""))
  } else if (number_of_files > 1) {
    cat(paste("Loading data from ", number_of_files, " files in sequential order...\n", sep = ""))
  } else {
    stop("ERROR: no input files detected")
  }
  
  # Parse each input file
  all_files_plate_data <- lapply(plate_data_filename, function(x) { parse_input_file(x) })
  
  # Combine into a single table
  all_files_plate_data <- merge_input_files_data(all_files_plate_data)
  
  # Add sample naming data
  plate_data_merged <- add_sample_metadata(all_files_plate_data, sample_metadata_filename)
  
  return(plate_data_merged)
  
}

# Description: generates summary stats for blanking group for each plate.
# Throws a warning if SD > 10% of mean
# MUST be one blank per plate for each group in that plate (good form)
summarize_blanks <- function(plate_table) {
  ### Summarize blanks
  blanks_raw <- filter(plate_table, Sample_type == "Blank")
  # TODO - check if 'Standard_conc' is really needed.
  blanks_grouped <- group_by(blanks_raw, Blanking_group, Sample_name, Plate_number)
  blanks_summ <- summarise(blanks_grouped, Blank_ave_abs = mean(Absorbance), Blank_stdDev_abs = sd(Absorbance))
  
  # Throw a warning if SD > 10% of mean
  for (i in 1:nrow(blanks_summ)) {
    if (blanks_summ$Blank_stdDev_abs[i] > (blanks_summ$Blank_ave_abs[i]) / 10) {
      warning(paste("Plate ", unique(plate_table$Plate_number), ": ", blanks_summ$Blanking_group[i], ": standard deviation is > 10% of mean of replicate blanks. Data could be fishy...", sep = ""))
    }
  }
  
  return(blanks_summ)
}

# Description: blanks the absorbances of all standards/samples
# Return: data table with the blanked absorbances
blank_absorbances <- function(plate_table, summarized_blanks) {
  
  # Remove sample name column from blank to avoid issue in joining
  summarized_blanks$Sample_name <- NULL
  
  # Join tables
  plate_table_blanked <- dplyr::left_join(plate_table, summarized_blanks, by = c("Plate_number", "Blanking_group"))
  
  # Blank tables
  plate_table_blanked$Absorbance_blanked <- plate_table_blanked$Absorbance - plate_table_blanked$Blank_ave_abs
  
  # TODO - consider removing some unnecessary columns introduced by the join
  return(plate_table_blanked)
  
}

# Description: determines standard curve for an individual plate
# Assume one standard for whole plate with different blanking options
# TODO - currently uses one standard for entire plate. Change to one per file?
make_standard_curve <- function(plate_table_blanked) {
  # plate_table <- plate_data_sep[[1]]
  
  ## Summarize standard curve data
  std_raw <- filter(plate_table_blanked, Sample_type == "Standard")
  std_grouped <- group_by(std_raw, Blanking_group, Treatment, Sample_name, Standard_conc, Plate_number)
  std_summ <- summarise(std_grouped, Ave_abs_blanked = mean(Absorbance_blanked), StdDev_abs_blanked = sd(Absorbance_blanked))
  
  # Check if standards belong to more than one blanking group. Could imply that there are multiple types of standards in a single plate, which this script cannot handle.
  std_Blanking_group <- as.character(unique(std_summ$Blanking_group))
  
  # Check that only one Blanking Group is present and throw a warning otherwise -- handling multiple is not yet supported.
  if (length(std_Blanking_group) > 1) {
    warning(paste("Detected standards of multiple Blanking Groups in Plate ", 
                  unique(plate_table_blanked$Plate_number), ". the dataset. The script is not yet able to handle this. Should only be one type of standard per plate. Your data could be unusual...", sep = ""))
  }
  
  # Check if blank absorbance is greater than absorbance of lowest standard
  if (min(std_summ$Ave_abs_blanked) < 0) {
    # Identify number of standards below blank
    stds_below_blank <- dplyr::filter(std_summ, Ave_abs_blanked < 0)
    std_names_below_blank <- unique(stds_below_blank$Sample_name)
    std_names_below_blank_readable <- glue::collapse(std_names_below_blank, sep = ", ")
    
    # Throw a warning
    warning(paste("Plate_number ", unique(plate_table_blanked$Plate_number), ": blank has higher absorbance than ", nrow(stds_below_blank), 
                  " of the standards (",  std_names_below_blank_readable, "). Will throw out all standards below blank.", sep = ""))
    
    # Remove all standards with absorbance lower than blank
    std_summ <- dplyr::filter(std_summ, Ave_abs_blanked > 0)
  }
  
  # Make linear trendline
  if (force_zero == TRUE) {
    trendline <- lm(Ave_abs_blanked ~ 0 + Standard_conc, data = std_summ) # Forcing through origin: https://stackoverflow.com/a/18947967, accessed 170815
  } else {
    trendline <- lm(Ave_abs_blanked ~ Standard_conc, data = std_summ)
  }
  
  # Summarize some trendline values
  if (force_zero == TRUE) {
    trendline_coeff <- c(0, coefficients(trendline)) # to make this match what the coefficients look like when not fixed to origin
  } else {
    trendline_coeff <- coefficients(trendline)
  }
  trendline_Rsquared <- summary(trendline)$r.squared
  trendline_summ <- data.frame("Intercept" = unname(trendline_coeff[1]), "Slope" = unname(trendline_coeff[2]), "R_squared" = trendline_Rsquared, "Plate_number" = unique(std_summ$Plate_number), stringsAsFactors = FALSE)
  
  # Return list of processed data
  std_curve_summary <- list(std_summ, trendline_summ)
  names(std_curve_summary) <- c("Standards_blanked", "Trendline")
  
  return(std_curve_summary)
}

# Description: summarizes unknowns
summarize_unknowns <- function(plate_table_blanked) {
  
  ## Summarize standard curve data
  unk_raw <- filter(plate_table_blanked, Sample_type == "Unknown")
  unk_grouped <- group_by(unk_raw, Blanking_group, Treatment, Sample_name, Dilution_factor, Plate_number, Replicate)
  summarized_unknowns <- summarise(unk_grouped, Ave_abs_blanked = mean(Absorbance_blanked), StdDev_abs_blanked = sd(Absorbance_blanked))
  
  # Throw a warning if the blanking group does not exist for an unknown.
  if (anyNA(summarized_unknowns$Ave_abs_blanked) == TRUE) {
    # TODO - add code to determine the exact blanking group that is missing
    warning(paste("Plate ", unique(plate_table_blanked$Plate_number), ": at least one blanking group for unknowns has no corresponding blank. Data will contain NA values.", sep = ""))
  }
  
  return(summarized_unknowns)
}

# Description: converts sample absorbances to concentrations for a plate
# TODO - split into multiple functions (calculate, check, plot)
convert_to_concentration <- function(summarized_unknowns, std_curve_summary) {
  
  # Unpack the standard curve summary
  std_curve_data <- std_curve_summary[[1]]
  std_curve_trendline <- std_curve_summary[[2]]
  
  # Convert to concentration using standard curve (linear model) AND dilution factor
  summarized_unknowns$Ave_concentration_uM <- (summarized_unknowns$Ave_abs_blanked - 
                                      std_curve_trendline$Intercept) / std_curve_trendline$Slope * summarized_unknowns$Dilution_factor
  
  # Get standard devations (also accounting for dilution factor)
  summarized_unknowns$StdDev_Concentration_uM <- (summarized_unknowns$StdDev_abs_blanked / 
                                         std_curve_trendline$Slope) * summarized_unknowns$Dilution_factor
  # For calculating std dev like this, see http://www.psychstat.missouristate.edu/introbook/sbk15.htm, accessed ~Jan. 2017
  
  # Throw a warning if some concentrations are negative
  if (min(summarized_unknowns$Ave_concentration_uM) <= 0) {
    neg_values_positions <- which(summarized_unknowns$Ave_concentration_uM <= 0)
    neg_values <- summarized_unknowns$Ave_concentration_uM[neg_values_positions]
    num_neg_values <- length(neg_values)
    neg_values_readable <- glue::collapse(round(neg_values, 3), sep = ", ")

    # TODO - omit this entirely?    
    # # Omit those from standard curve plotting data frame (but keep in the unknowns data)
    # summarized_unknowns_plot <- summarized_unknowns[-neg_values_positions,]
    
    # Report what was done
    if (num_neg_values == 1) {
      warning("Plate_number ", unique(summarized_unknowns$Plate_number), ": ", num_neg_values, " sample has a negative concentration based on standard curve (",
              glue::collapse(round(neg_values, 3), sep = ", "), ").", sep = "")
    } else if (num_neg_values > 1) {
      warning("Plate_number ", unique(summarized_unknowns$Plate_number), ": ", num_neg_values, " samples have negative concentrations based on standard curve (",
              neg_values_readable, ").", sep = "")
    }
    
    # (Probably rare:) Check if negative absorbances remain even after removing negative concentrations
    if (min(summarized_unknowns_plot$Ave_abs_blanked) < 0) {
      neg_abs_positions <- which(summarized_unknowns_plot$Ave_abs_blanked <= 0)
      
      warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": also note that ", num_neg_values, " additional samples have positive concentrations but negative blanked absorbances... something could be odd with the data.", sep = ""))
    }
    
  } else {
    # No issues with negative concentrations.
    # TODO - omit making this secondary data table if I end up choosing to never omit values from the plot.
    summarized_unknowns_plot <- summarized_unknowns
  }
  
  # Generate error bar values in plotting data frame ahead of time and see if any are below zero (will cause error due to log scale)
  summarized_unknowns_plot$errorbar_min <- summarized_unknowns_plot$Ave_abs_blanked - summarized_unknowns_plot$StdDev_abs_blanked
  summarized_unknowns_plot$errorbar_max <- summarized_unknowns_plot$Ave_abs_blanked + summarized_unknowns_plot$StdDev_abs_blanked
  
  if (min(summarized_unknowns_plot$errorbar_max) < 0) {
    # Max error bar should not be < 0 at this point, because negative data points for concentration were already removed
    warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": something seems wrong with the error bars on samples in the standard curve plots...", sep = ""))
    
  } else if (min(summarized_unknowns_plot$errorbar_min) < 0) {
    # Eliminate negative values and replace with the value of the point itself (so bottom bars will essentially be unplotted)
    neg_errorbar_pos <- which(summarized_unknowns_plot$errorbar_min < 0)
    summarized_unknowns_plot$errorbar_min[neg_errorbar_pos] <- summarized_unknowns_plot$Ave_abs_blanked[neg_errorbar_pos]
    
    warning(paste("Plate_number ", unique(summarized_unknowns$Plate_number), ": had to remove negative min. error bar positions for ", length(neg_errorbar_pos), 
                " sample(s) in the std. curve plot in order to make the sample(s) plot-able. Unchanged in the actual data, however...", sep = ""))
  }
  
  # Figure out where to put the trend line equation text on the plot
  min_x <- min(std_curve_data$Standard_conc)
  max_x <- max(std_curve_data$Standard_conc)
  min_y <- min(std_curve_data$Ave_abs_blanked)
  max_y <- max(std_curve_data$Ave_abs_blanked)
  # TODO - pull these out to the top of the script?
  x_coord <- (max_x - min_x) * 0.05 # arbitrary position 5% to the right of the y axis
  y_coord <- (max_y - min_y) * 0.8 # arbitrary position 80% above the x axis
  
  ## Make standards plot without samples
  std_plot <- ggplot(std_curve_data, aes(x = Standard_conc, y = Ave_abs_blanked)) +
    geom_smooth(method = "lm", se = T, colour = "purple") +
    geom_errorbar(aes(x = Standard_conc, ymin = Ave_abs_blanked-StdDev_abs_blanked, 
                      ymax = Ave_abs_blanked+StdDev_abs_blanked), width = 0, size = 0.8, alpha = 0.8) +
    geom_point(alpha = 0.9, size = 3) +
    annotate("text", x = x_coord, y = y_coord, 
             label = paste("y = ", round(std_curve_trendline$Slope, digits = 5), 
                           "x + ", round(std_curve_trendline$Intercept, digits = 5), 
                           "\n R^2 = ", round(std_curve_trendline$R_squared, digits = 5), sep = ""), size = 3) +
    theme_bw() +
    # Add theme elements to make the plot look nice
    theme(panel.grid = element_blank(), title = element_text(size = 10), axis.title = element_text(size = 12), 
          strip.text = element_text(size = 10), strip.background = element_rect(fill = "#e6e6e6"),
          panel.border = element_rect(colour = "black", size = 1), panel.spacing.y = unit(3, "mm"), panel.spacing.x = unit(0, "mm"),
          axis.text.x = element_text(size = 10, colour = "black"), axis.text.y = element_text(size = 10, colour = "black"),
          axis.ticks = element_line(size = 0.5), axis.line = element_line(colour = "black", size = 0.5),
          legend.text = element_text(size = 7), legend.title = element_blank(),
          legend.key = element_rect(colour = "grey", size = 0.3), legend.key.size = unit(3, "mm"),
          legend.spacing = unit(1, "mm"), legend.box.just = "left", plot.margin = unit(c(2,2,2,2), "mm")) +
    #         See http://stackoverflow.com/questions/1330989/rotating-and-spacing-axis-labels-in-ggplot2 (approx. Jan 27, 2016) for vertical x-axis labels
    # scale_x_continuous(limits = c(0, NA)) +
    # scale_y_continuous(limits = c(0, NA)) +
    scale_x_log10() +
    scale_y_log10() +
    annotation_logticks() +
    xlab("Concentration (uM)") +
    ylab("Absorbance (blanked)") +
    ggtitle(paste("Plate_number: ", unique(summarized_unknowns$Plate_number), sep = ""))
  
  # Add on samples to the standard plot
  unk_plot <- std_plot +
    geom_errorbar(data = summarized_unknowns_plot, 
                  aes(x = (Ave_concentration_uM / Dilution_factor), 
                      ymin = errorbar_min, ymax = errorbar_max), 
                  width = 0, size = 0.8, alpha = 0.8, colour = "darkcyan") +
    geom_point(data = summarized_unknowns_plot, 
               aes((Ave_concentration_uM / Dilution_factor), Ave_abs_blanked), 
               shape = 21, alpha = 0.8, size = 3, fill = "darkcyan")
  
  output_list <- list(summarized_unknowns, std_plot, unk_plot)
  names(output_list) <- c("calculated_concentrations", "std_plot", "std_plot_with_unknowns")
  return(output_list)

}

# Description: creates a 96 well plate-style figure of the parsed data for checking purposes
visual_check <- function(plate_table) {
  # plate_table <- plate_data_sep[[2]]
  
  # Split wells into row and column
  plate_table$Well_row <- as.character(substr(plate_table$Well, start = 1, stop = 1))
  plate_table$Well_col <- as.numeric(substr(plate_table$Well, start = 2, stop = 3))
  
  # Make table of all wells in a 96 well plate to merge with main table
  # (in case some wells have been omitted by the user from the main table; this way, the entire 96 well plate will appear in the figure)
  wells_96 <- data.frame("Well_row" = c(rep("A", 12), rep("B", 12), rep("C", 12), rep("D", 12), rep("E", 12), rep("F", 12), rep("G", 12), rep("H", 12)),
                         "Well_col" = rep(c(1:12), 8), stringsAsFactors = FALSE)
  
  # Merge tables
  plate_table <- dplyr::full_join(plate_table, wells_96, by = c("Well_row", "Well_col"))
  
  # Put rows in order
  plate_table$Well_row <- factor(plate_table$Well_row, levels = rev(c("A", "B", "C", "D", "E", "F", "G", "H")), ordered = TRUE)
  
  # Make annotation text
  plate_table$Annotation <- paste(plate_table$Sample_name, " ", plate_table$Replicate, "\n", plate_table$Absorbance, sep = "")
  # Clean out ones with no sample
  for (i in 1:length(plate_table$Annotation)) {
    if (plate_table$Sample_name[i] == "" | is.na(plate_table$Sample_name[i]) == TRUE) {
      plate_table$Annotation[i] <- ""
    }
  }
  
  plate_diagram <- ggplot(plate_table, aes(factor(Well_col), Well_row)) +
    geom_point(aes(fill = Absorbance), shape = 21, size = 18) +
    geom_text(aes(label = Annotation), size = 2) +
    scale_fill_gradientn(colours = c("#ffffff", "#ff3399", "#660066"), limits = c(0,1)) + # Used limits to set absolute colour scale, as recommended at https://stackoverflow.com/a/21538521 (accessed Oct 2nd, 2017)
    xlab("") +
    ylab("") +
    ggtitle(unique(plate_table$Date))
  
  return(plate_diagram)
}

# Description: fully processes data for a single plate
calculate_plate_data <- function(plate_table) {
  summarized_blanks <- summarize_blanks(plate_table)
  
  plate_table_blanked <- blank_absorbances(plate_table, summarized_blanks)
  
  summarized_standards_list <- make_standard_curve(plate_table_blanked)
  
  summarized_unknowns <- summarize_unknowns(plate_table_blanked)
  
  # TODO - long-term, make separate functions for plotting versus summarizing unknowns
  calculated_concentrations_all <- convert_to_concentration(summarized_unknowns, summarized_standards_list)
  
  # Unpack output
  calculated_concentrations <- calculated_concentrations_all[[1]]
  std_plot <- calculated_concentrations_all[[2]]
  unk_plot <- calculated_concentrations_all[[3]]
  
  # Also unpack output from 'summarized_standards_list'
  summarized_standards <- summarized_standards_list[[1]]
  summarized_trendlines <- summarized_standards_list[[2]]
  
  # Run visual check
  plate_diagram <- visual_check(plate_table)
  
  output_list <- list(calculated_concentrations, summarized_blanks, summarized_standards, summarized_trendlines, std_plot, unk_plot, plate_diagram)
  names(output_list) <- c("Unknowns", "Blanks", "Standards", "Trendlines", "Std_curve_plot", "Std_curve_plot_with_unknowns", "Plate_diagrams")
  
  return(output_list)
  
}

# Description: Given a nested list with identical structure across level 1, moves the list item of identical 
# name or position from all lists into their own primary list
subset_list <- function(all_plate_data_calculated, item) {
  
  similar_items <- lapply(names(all_plate_data_calculated), 
                          function(x) { return(all_plate_data_calculated[[x]][[item]])})
  names(similar_items) <- names(all_plate_data_calculated)
  
  return(similar_items)
}

# Description: clarified information in the summary tables
summarize_processed_data <- function(plate_data_merged, separated_list_entries) {
  # Join tables from different plates
  # TODO - make this more elegant
  separated_list_entries[["Unknowns"]] <- dplyr::bind_rows(separated_list_entries[["Unknowns"]])
  separated_list_entries[["Blanks"]] <- dplyr::bind_rows(separated_list_entries[["Blanks"]])
  separated_list_entries[["Standards"]] <- dplyr::bind_rows(separated_list_entries[["Standards"]])
  separated_list_entries[["Trendlines"]] <- dplyr::bind_rows(separated_list_entries[["Trendlines"]])
  
  # Retrieve any additional metadata info provided by the user
  # Remove irrelevant information
  cols_to_remove <- c("Well", "Absorbance", "Sample_type", "Blanking_group", "Dilution_factor", "Standard_conc")
  cols_nums_to_remove <- match(cols_to_remove, colnames(plate_data_merged))
  extra_sample_info <- unique(plate_data_merged[,-(cols_nums_to_remove)])
  merging_cols <- c("Plate_number", "Sample_name", "Replicate", "Treatment") # to use with join later
  
  # Summarize the unknowns (samples) data and re-order for clarity
  separated_list_entries$Unknowns <- separated_list_entries$Unknowns[,c(5,3,6,2,4,1,7,8,9,10)]
  # Join in other sample info provided by the user
  separated_list_entries$Unknowns <- dplyr::inner_join(separated_list_entries$Unknowns, extra_sample_info, by = merging_cols)
  
  # Summarize standards and re-order for clarity
  separated_list_entries$Standards <- separated_list_entries$Standards[,c(5,3,4,2,1,6,7)]
  
  # Summarize blanks and re-order for clarity
  separated_list_entries$Blanks <- separated_list_entries$Blanks[,c(3,1,2,4,5)]
  
  # Summarize trendline and re-order for clarity
  separated_list_entries$Trendlines <- separated_list_entries$Trendlines[,c(4,2,1,3)]
  
  return(separated_list_entries)
  
}

# Description: writes Excel table of summarized data
write_excel_table <- function(output_filenames_prefix, summarized_table_list) {
  
  table_sheetnames <- names(summarized_table_list)
  
  # Save as Excel workbook with multiple sheets
  xlsx_table_filename <- paste(output_filenames_prefix, "_calculations.xlsx", sep = "")
  for (i in 1:length(summarized_table_list)) {
    if (i == 1) {
      write.xlsx2(as.data.frame(summarized_table_list[[i]]), xlsx_table_filename, 
                  sheetName = table_sheetnames[[i]], col.names=TRUE, row.names=FALSE, append=FALSE)
    } else {
      write.xlsx2(as.data.frame(summarized_table_list[[i]]), xlsx_table_filename, 
                  sheetName = table_sheetnames[[i]], col.names=TRUE, row.names=FALSE, append=TRUE)
    }
  }
  
}

# Description: prints a single PDF file with all plots in the input list (item_name within summarized_plot_list)
print_plot_file <- function(output_filenames_prefix, summarized_plot_list, item_name) {
  
  plot_filename <- paste(output_filenames_prefix, "_", item_name, ".pdf", sep = "")
  
  # TODO - make this more elegant
  if (item_name == "Plate_diagrams") {
    pdf(file = plot_filename, width = 10, height = 6)
  } else if (item_name != "Plate_diagrams") {
    pdf(file = plot_filename, width = 7, height = 7)
  }
  
  print(summarized_plot_list[[item_name]])
  # See https://stackoverflow.com/a/29834646, accessed 170815
  dev.off()
  
}

main <- function() {
  # Run command line version if requested
  if (RUN_COMMAND_LINE == TRUE) {
    parse_command_line_input()
  }
  
  # Assign default naming prefix if not assigned by user
  if (is.na(output_filenames_prefix) == TRUE) {
    output_filenames_prefix <- substr(plate_data_filename[1], 1, nchar(plate_data_filename[1])-4)
  }
  
  # Startup messages
  cat(paste("Running 96_well_spec_analysis.R, version: ", SCRIPT_VERSION, "\n\n", sep = ""))
  cat(paste("Plate data filenames:", plate_data_filename, "\n"))
  cat(paste("Metadata filename:", sample_metadata_filename, "\n"))
  cat(paste("Prefix for output files:", output_filenames_prefix, "\n"))
  cat(paste("Parse raw input plate data?:", parse_raw_plate_data, "\n"))
  cat(paste("Force standard curves through zero?:", force_zero, "\n"))
  cat("\n")
  
  ##### Import plate data
  if (parse_raw_plate_data == TRUE) {
    cat("Parsing plate data...\n")
    plate_data_merged <- parse_raw_data(plate_data_filename, sample_metadata_filename)
    cat("Successfully read in plate data and sample naming data.\n")
    
    # Export combined data
    merged_data_filename <- paste(output_filenames_prefix, "_raw_data.tsv", sep = "")
    write.table(plate_data_merged, file = merged_data_filename, sep = "\t", col.names = TRUE, row.names = FALSE)
    
  } else {
    # Read in pre-merged plate/sample data
    plate_data_merged <- read.table(plate_data_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
    
    # Check if required columns exist. If they do not, exit early.
    required_colnames <- c("Plate_number", "Well", "Absorbance", "Sample_name", "Replicate", "Sample_type", "Treatment", "Blanking_group", "Dilution_factor", "Standard_conc")
    req_col_test <- unique(required_colnames %in% colnames(plate_data_merged))
    if (length(req_col_test) != 1 | req_col_test[1] == FALSE) {
      stop("ERROR: Missing required table column (should include plate absorbance data and sample naming data; see README.md). Exiting...")
    }
  }
  
  ##### Process standards and unknowns
  cat("Calculating concentrations...\n")
  
  # First, split the raw data into a list of individual plates
  plate_data_sep <- lapply(unique(plate_data_merged$Plate_number), 
                           function(x) {filter(plate_data_merged, Plate_number == x)})
  names(plate_data_sep) <- unique(plate_data_merged$Plate_number)
  
  # Calculate plate data
  all_plate_data_calculated <- lapply(names(plate_data_sep), 
                               function(x) {calculate_plate_data(plate_data_sep[[x]])})
  names(all_plate_data_calculated) <- names(plate_data_sep)
  
  ##### Summarize output
  cat("Summarizing output...\n")
  
  # Move each list item into its own sub-list with like kinds
  separated_list_entries <- lapply(names(all_plate_data_calculated[[1]]), 
                                   function(x) { subset_list(all_plate_data_calculated, x) })
  # TODO - consider hard-coding this somewhere at the top. This line is also present in another function.
  names(separated_list_entries) <- c("Unknowns", "Blanks", "Standards", "Trendlines", "Std_curve_plot", "Std_curve_plot_with_unknowns", "Plate_diagrams")
  
  # Clean up output and separate tables from lists (manually!)
  summarized_data_list <- summarize_processed_data(plate_data_merged, separated_list_entries)
  summarized_table_list <- summarized_data_list[c(1:4)]
  summarized_plot_list <- summarized_data_list[c(5:7)]
  
  cat("Printing summary files...\n")
  # Write summary Excel table
  write_excel_table(output_filenames_prefix, summarized_table_list)
    
  # Also export unknowns as TSV
  table_filename_unknowns <- paste(output_filenames_prefix, "_unknowns.tsv", sep = "")
  write.table(summarized_data_list$Unknowns, file = table_filename_unknowns, sep = "\t", 
              col.names = TRUE, row.names = FALSE)
  
  # Print plots
  lapply(names(summarized_plot_list), function(x) { print_plot_file(output_filenames_prefix, 
                                                                    summarized_plot_list, x)})
  
  cat("\n96_well_spec_analysis.R: finished.\n\n")
  
}

main()
